package cqb13.NumbyHack.modules.general;

import cqb13.NumbyHack.NumbyHack;
import cqb13.NumbyHack.events.Teleport;
import meteordevelopment.meteorclient.events.entity.player.FinishUsingItemEvent;
import meteordevelopment.meteorclient.events.packets.PacketEvent;
import meteordevelopment.meteorclient.events.render.Render3DEvent;
import meteordevelopment.meteorclient.events.world.TickEvent;
import meteordevelopment.meteorclient.renderer.ShapeMode;
import meteordevelopment.meteorclient.settings.*;
import meteordevelopment.meteorclient.systems.modules.Module;
import meteordevelopment.meteorclient.utils.Utils;
import meteordevelopment.meteorclient.utils.misc.Keybind;
import meteordevelopment.meteorclient.utils.render.RenderUtils;
import meteordevelopment.meteorclient.utils.render.color.SettingColor;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.TeleportConfirmC2SPacket;
import net.minecraft.network.packet.s2c.play.PlayerPositionLookS2CPacket;
import net.minecraft.util.math.Vec3d;
import java.util.LinkedList;
import java.util.Queue;

/**
 * 基于 Meteor Rejects
 */
public class ChorusExploit extends Module {
    private final SettingGroup sgGeneral = settings.getDefaultGroup();
    private final SettingGroup sgRender = settings.createGroup("渲染");

    private final Setting<PositionMode> positionMode = sgGeneral.add(new EnumSetting.Builder<PositionMode>()
            .name("位置模式")
            .description("你的传送位置是如何计算的。")
            .defaultValue(PositionMode.Particle)
            .build()
    );

    private final Setting<Boolean> onItemSwitch = sgGeneral.add(new BoolSetting.Builder()
            .name("切换物品时传送")
            .description("切换物品时传送你。")
            .defaultValue(true)
            .build()
    );

    private final Setting<Boolean> onDeactivate = sgGeneral.add(new BoolSetting.Builder()
            .name("停用时传送")
            .description("模块停用时传送你。")
            .defaultValue(false)
            .build()
    );

    private final Setting<Keybind> onKey = sgGeneral.add(new KeybindSetting.Builder()
            .name("按键传送")
            .description("按下按键时传送。")
            .defaultValue(Keybind.none())
            .action(this::sendPackets)
            .build()
    );

    private final Setting<Boolean> autoTeleport = sgGeneral.add(new BoolSetting.Builder()
            .name("自动传送")
            .description("在固定的tick数后自动传送你。")
            .defaultValue(false)
            .build()
    );

    private final Setting<Integer> ticksToTeleport = sgGeneral.add(new IntSetting.Builder()
            .name("传送前的tick数")
            .description("自动传送前等待的tick数。")
            .defaultValue(40)
            .min(0)
            .sliderMax(100)
            .visible(autoTeleport::get)
            .build()
    );

    // 渲染
    private final Setting<Boolean> renderActual = sgRender.add(new BoolSetting.Builder()
            .name("设置位置")
            .description("将你的客户端设置为实际位置。")
            .defaultValue(true)
            .build()
    );

    private final Setting<ShapeMode> shapeMode = sgRender.add(new EnumSetting.Builder<ShapeMode>()
            .name("形状模式")
            .description("形状的渲染方式。")
            .defaultValue(ShapeMode.Both)
            .build()
    );

    private final Setting<SettingColor> sideColor = sgRender.add(new ColorSetting.Builder()
            .name("侧面颜色")
            .description("目标方块渲染的侧面颜色。")
            .defaultValue(new SettingColor(146,188,98, 75))
            .build()
    );

    private final Setting<SettingColor> lineColor = sgRender.add(new ColorSetting.Builder()
            .name("线条颜色")
            .description("目标方块渲染的线条颜色。")
            .defaultValue(new SettingColor(146,188,98))
            .build()
    );

    private final Setting<Boolean> drawLine = sgRender.add(new BoolSetting.Builder()
            .name("绘制追踪线")
            .description("绘制一条线到你将要到达的位置。")
            .defaultValue(true)
            .build()
    );

    private final Setting<SettingColor> lineColour = sgRender.add(new ColorSetting.Builder()
            .name("追踪线颜色")
            .description("线条的颜色。")
            .defaultValue(new SettingColor(146,188,98, 255))
            .visible(drawLine::get)
            .build()
    );

    private int slot;
    private int delay = 0;
    private boolean ateChorus, sending, gotPosition = false;
    private double posX, posY, posZ, cposX, cposY, cposZ;
    private final Queue<TeleportConfirmC2SPacket> telePackets = new LinkedList<>();

    public ChorusExploit() {
        super(NumbyHack.CATEGORY, "chorus-exploit", "通过合唱果实延迟传送。");
    }

    @Override
    public void onActivate() {
        ateChorus = false;
        delay = 0;
        telePackets.clear();
        gotPosition = false;
    }

    @Override
    public void onDeactivate() {
        if (Utils.canUpdate() && ateChorus && onDeactivate.get()) {
            sendPackets();
        }
        telePackets.clear();
        gotPosition = false;
    }

    @EventHandler
    private void onPacketSend(PacketEvent.Send event) {
        if (event.packet instanceof TeleportConfirmC2SPacket telepacket && ateChorus && !sending) {
            telePackets.add(telepacket);
            event.cancel();
        }
    }

    @EventHandler
    private void onPacketReceive(PacketEvent.Receive event) {
        if (event.packet instanceof PlayerPositionLookS2CPacket posPacket && ateChorus) {
            event.setCancelled(true);
            if (positionMode.get() == PositionMode.PosLook) {
                cposX = posPacket.getX();
                cposY = posPacket.getY();
                cposZ = posPacket.getZ();
                gotPosition = true;
            }
        }
    }

    @EventHandler
    private void onTick(TickEvent.Pre event) {
        if (ateChorus) {
            delay++;
            if (!mc.player.getPos().equals(new Vec3d(posX, posY, posZ)) && renderActual.get()) {
                mc.player.setPos(posX, posY, posZ);
            }

            if (autoTeleport.get() && delay >= ticksToTeleport.get()) {
                sendPackets();
            }

            if (onItemSwitch.get() && slot != mc.player.getInventory().selectedSlot) {
                sendPackets();
            }
        }
    }

    @EventHandler
    private void onEat(FinishUsingItemEvent event) {
        if (event.itemStack.getItem().equals(Items.CHORUS_FRUIT)) {
            posX = mc.player.getX();
            posY = mc.player.getY();
            posZ = mc.player.getZ();
            ateChorus = true;
            slot = mc.player.getInventory().selectedSlot;
        }
    }

    @EventHandler
    private void onRender3D(Render3DEvent event) {
        if (ateChorus && gotPosition) {
            event.renderer.box(cposX, cposY, cposZ, cposX + 1, cposY + 1, cposZ + 1, sideColor.get(), lineColor.get(), shapeMode.get(), 0);
        }
        if (drawLine.get() && ateChorus && gotPosition) {
            event.renderer.line(RenderUtils.center.x, RenderUtils.center.y, RenderUtils.center.z, cposX, cposY + 1, cposZ, lineColour.get());
        }
    }

    @EventHandler
    private void onTeleportParticle(Teleport event) {
        if (ateChorus && positionMode.get() == PositionMode.Particle) {
            cposX = event.x;
            cposY = event.y;
            cposZ = event.z;
            gotPosition = true;
        }
    }

    private void sendPackets() {
        sending = true;

        while (!telePackets.isEmpty()) {
            mc.getNetworkHandler().sendPacket(telePackets.poll());
        }

        delay = 0;
        ateChorus = false;
        sending = false;
        gotPosition = false;
    }

    @Override
    public String getInfoString() {
        if (autoTeleport.get() && ateChorus) return String.valueOf(ticksToTeleport.get() - delay);
        return null;
    }

    public enum PositionMode {
        Particle,
        PosLook,
        None
    } // 修复方块位置，添加聊天反馈 / 聊天中的选项位置
}
